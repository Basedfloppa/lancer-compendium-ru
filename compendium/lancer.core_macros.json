{
  "label": "Lancer Макросы",
  "folders": {
    "Core": "Основные механики",
    "AoE Templates": "Шаблоны зон"
  },
  "entries": {
    "Blast 1": {
      "name": "Взрыв 1",
      "command": "game.lancer.canvas.WeaponRangeTemplate.fromRange({\n    type: \"Blast\",\n    val: 1,\n}).placeTemplate()\n    .then(t => {\n        if (t) game.lancer.targetsFromTemplate(t.id);\n    }\n);"
    },
    "Blast 2": {
      "name": "Взрыв 2",
      "command": "game.lancer.canvas.WeaponRangeTemplate.fromRange({\n    type: \"Blast\",\n    val: 2,\n}).placeTemplate()\n    .then(t => {\n        if (t) game.lancer.targetsFromTemplate(t.id);\n    }\n);"
    },
    "Blast 3": {
      "name": "Взрыв 3",
      "command": "game.lancer.canvas.WeaponRangeTemplate.fromRange({\n    type: \"Blast\",\n    val: 3,\n}).placeTemplate()\n    .then(t => {\n        if (t) game.lancer.targetsFromTemplate(t.id);\n    }\n);"
    },
    "Burst 1": {
      "name": "Всплеск 1",
      "command": "game.lancer.canvas.WeaponRangeTemplate.fromRange({\n    type: \"Burst\",\n    val: 1,\n}).placeTemplate()\n    .then(t => {\n        if (t) game.lancer.targetsFromTemplate(t.id);\n    }\n);"
    },
    "Burst 2": {
      "name": "Всплеск 2",
      "command": "game.lancer.canvas.WeaponRangeTemplate.fromRange({\n    type: \"Burst\",\n    val: 2,\n}).placeTemplate()\n    .then(t => {\n        if (t) game.lancer.targetsFromTemplate(t.id);\n    }\n);"
    },
    "Burst 3": {
      "name": "Всплеск 3",
      "command": "game.lancer.canvas.WeaponRangeTemplate.fromRange({\n    type: \"Burst\",\n    val: 3,\n}).placeTemplate()\n    .then(t => {\n        if (t) game.lancer.targetsFromTemplate(t.id);\n    }\n);"
    },
    "Burst 5": {
      "name": "Всплеск 5",
      "command": "game.lancer.canvas.WeaponRangeTemplate.fromRange({\n    type: \"Burst\",\n    val: 5,\n}).placeTemplate()\n    .then(t => {\n        if (t) game.lancer.targetsFromTemplate(t.id);\n    }\n);"
    },
    "Cone 3": {
      "name": "Конус 3",
      "command": "game.lancer.canvas.WeaponRangeTemplate.fromRange({\n    type: \"Cone\",\n    val: 3,\n}).placeTemplate()\n    .then(t => {\n        if (t) game.lancer.targetsFromTemplate(t.id);\n    }\n);"
    },
    "Cone 5": {
      "name": "Конус 5",
      "command": "game.lancer.canvas.WeaponRangeTemplate.fromRange({\n    type: \"Cone\",\n    val: 5,\n}).placeTemplate()\n    .then(t => {\n        if (t) game.lancer.targetsFromTemplate(t.id);\n    }\n);"
    },
    "Cone 7": {
      "name": "Конус 7",
      "command": "game.lancer.canvas.WeaponRangeTemplate.fromRange({\n    type: \"Cone\",\n    val: 7,\n}).placeTemplate()\n    .then(t => {\n        if (t) game.lancer.targetsFromTemplate(t.id);\n    }\n);"
    },
    "Line 3": {
      "name": "Линия 3",
      "command": "game.lancer.canvas.WeaponRangeTemplate.fromRange({\n    type: \"Line\",\n    val: 3,\n}).placeTemplate()\n    .then(t => {\n        if (t) game.lancer.targetsFromTemplate(t.id);\n    }\n);"
    },
    "Line 5": {
      "name": "Линия 5",
      "command": "game.lancer.canvas.WeaponRangeTemplate.fromRange({\n    type: \"Line\",\n    val: 5,\n}).placeTemplate()\n    .then(t => {\n        if (t) game.lancer.targetsFromTemplate(t.id);\n    }\n);"
    },
    "Line 8": {
      "name": "Линия 8",
      "command": "game.lancer.canvas.WeaponRangeTemplate.fromRange({\n    type: \"Line\",\n    val: 8,\n}).placeTemplate()\n    .then(t => {\n        if (t) game.lancer.targetsFromTemplate(t.id);\n    }\n);"
    },
    "Line 10": {
      "name": "Линия 10",
      "command": "game.lancer.canvas.WeaponRangeTemplate.fromRange({\n    type: \"Line\",\n    val: 10,\n}).placeTemplate()\n    .then(t => {\n        if (t) game.lancer.targetsFromTemplate(t.id);\n    }\n);"
    },
    "Line 20": {
      "name": "Линия 20",
      "command": "game.lancer.canvas.WeaponRangeTemplate.fromRange({\n    type: \"Line\",\n    val: 20,\n}).placeTemplate()\n    .then(t => {\n        if (t) game.lancer.targetsFromTemplate(t.id);\n    }\n);"
    },

    "Custom Paint Job": {
      "name": "Персональная окраска",
      "command": "// Этот макрос предназначен для использования с Triggler из Combat Utility Belt. // Иначе его можно применять как альтернативу ручному запуску макроса Structure. // Также он «уничтожает» систему «Персональная окраска», чтобы отметить её использование между полными ремонтами.\nlet cpjActor = game.actors.get(canvas.tokens.controlled[0].actor.id); //console.log(cpjActor);\nasync function scratchedThePaint(cpjId) {\n    await cpjActor.update({\"system.hp.value\": 1});\n    await cpjActor.updateEmbeddedDocuments(\"Item\", [{_id: cpjId, 'system.destroyed': true}])\n    return \"Готово.\";\n};\nif (canvas.tokens.controlled.length !== 1) {\n    ui.notifications.error(\"Пожалуйста, выберите одну цель\");\n    return;\n}\nlet cpj = cpjActor.items.find(\n    i => i.system.lid === \"ms_custom_paint_job\"\n); if (cpj) {\n  if (!cpj.system.destroyed) {\n      console.log(\"Персональная окраска найдена.\");\n      let roll = new Roll('1d6');\n      await roll.roll();\n    const html = await renderTemplate(\n      `systems/${game.system.id}/templates/chat/generic-card.hbs`,\n    {\n      title: \"Персональная окраска\",\n      description: \"\",\n      roll,\n      roll_tt: await roll.getTooltip(),\n    });\n    const chatData = {\n      type: CONST.CHAT_MESSAGE_TYPES.ROLL,\n      roll: roll,\n      speaker: {\n      actor: cpjActor,\n      token: cpjActor?.token,\n      alias: !!cpjActor?.token ? cpjActor.token.name : null,\n      },\n      content: html,\n    }\n    await ChatMessage.create(chatData);\n    console.log(`CPJ выбросил ${roll.total}`);\n    if (roll.total === 6) {\n      await scratchedThePaint(cpj._id)\n    } else {\n      await cpjActor.beginStructureFlow();\n    }\n    return;\n  } else {\n    console.log(\"Персональная окраска уже была использована.\");\n  }\n} // Если мы здесь, либо у актора нет ПО, либо она уже была использована.\ncanvas.tokens.controlled[0].actor.beginStructureFlow();"
    },

    "Dismount/Eject": {
      "name": "Спешивание/Катапультация",
      "command": "if (!actor?.is_mech()) return;\nconst pilot = await fromUuid(actor.system.pilot?.id);\nif (!pilot) return;\n\ngame.lancer.canvas.WeaponRangeTemplate.fromRange({\n    type: \"Blast\",\n    val: 0.1,\n})\n    .placeTemplate()\n    .then(async t => {\n        if (!t) return;\n        const [x, y] = canvas.grid.getTopLeft(t.x, t.y);\n        await TokenDocument.create(\n            { ...pilot.prototypeToken, actorId: pilot.id, x, y },\n            { parent: canvas.scene }\n        );\n        await t.delete();\n    });"
    },

    "Mimic Gun": {
      "name": "Имитационное оружие",
      "command": "// Рассчитать дальность для Имитационного оружия.\nasync function getRange() {\n  const roll = await new Roll(\"d20\").roll({ async: true });\n  const text =\n  `<i class=\\\"cci cci-range i--m\\\"></i> ${roll.total}` +\n  `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;` +\n  `${Math.ceil(roll.total / 2) + 1} ` +\n  `<i class=\\\"cci cci-kinetic i--m damage--kinetic\\\"></i>`;\n  return text;\n}\n\n// Построить HTML-таблицу сообщения для чата.\nasync function buildMessageTable() {\n  const messageTable =  \n    \"<b><h2>Дальность имитационного оружия</h2></b>\" + \n    \"<p><b>Дальность X: </b>\" + await getRange() +\n    \"<hr><p><b>Дальность Y: </b>\" + await getRange() +\n    \"<hr><p><b>Дальность Z: </b>\" + await getRange()\n  return messageTable;\n}\n\n// Сконструировать объект чат-сообщения.\nasync function buildChatData() {\n  return {\n    user: game.user.id,\n    speaker: ChatMessage.getSpeaker(),\n    content: await buildMessageTable()\n  };\n}\n\nChatMessage.create(await buildChatData(), {});"
    },

    "Ruin Tokens": {
      "name": "Разрушенный",
      "command": "function isBiological(token) {\n  let actorItems = game.actors.filter(x => x.id === token.document.actorId)[0].items;\n  for (let item of actorItems.entries()) {\n    if (item[1].type === \"npc_class\" && item[1].system.role === \"biological\") {\n      console.log(`${token.name} является биологическим.`);\n      return true;\n    } else {\n      console.log(`${token.name} не является биологическим.`);\n      return false;\n    }\n  }\n}\n\nif (canvas.tokens.controlled.length === 0) {\n  ui.notifications.error(\"Пожалуйста, выберите одну или несколько целей\");\n  return;\n}\ncanvas.tokens.controlled.forEach(async t => {\n  if (isBiological(t)) {\n    ui.notifications.info(`${t.name} биологический — пропускаю операцию`);\n    return;\n  }\n  // НАСТРОЙКИ НИЖЕ:\n  // Путь к данным, где хранятся ваши изображения.\n  let IMAGE_PATH = \"lancer-wrecks\";\n\n  // Сопоставление размеров с подпапками под IMAGE_PATH.\n  // Ключи — возможные размеры LancerActor; значения — имена подпапок.\n  // Храните изображения по размерам в соответствующих подпапках.\n  let SIZE_PATHS = {\n    0.5: \"S-HALF\",\n    1: \"S1\",\n    2: \"S2\",\n    3: \"S3\",\n    4: \"S4\",\n  };\n\n  // Скрипт:\n  let size = t.actor.system.size;\n  let sizePath = SIZE_PATHS[size];\n  var imgString;\n  if (!!sizePath) {\n    var wreckFileList;\n    try {\n      let wreckFilePicker = await FilePicker.browse(\"data\", `/${IMAGE_PATH}/${sizePath}`);\n      wreckFileList = wreckFilePicker.files;\n      console.log(wreckFileList);\n      let numImages = wreckFileList.length;\n      // Случайное число от 1 до N, где N — число изображений для данного размера меха.\n      let rand = Math.floor(Math.random() * numImages);\n      imgString = wreckFileList[rand];\n    } catch (error) {\n      ui.notifications.warn(`${error}. Пропускаю замену изображения.`);\n    }\n  } else {\n    ui.notifications.warn(\n      `Отсутствует путь к изображениям требуемого размера ${size} для ${t.name}. Пропускаю замену изображения.`\n    );\n  }\n\n  console.log(`Выбран ${imgString} для ${t.name}`);\n\n  let data = [\n    {\n      _id: t.id,\n      \"texture.src\": imgString,\n    },\n  ];\n\n  canvas.scene.updateEmbeddedDocuments(\"Token\", data);\n  t.actor.update({ \"system.hp\": size * 10, \"system.heat\": 0, \"system.burn\": 0 });\n  game.combat.getCombatantByToken(t.id)?.delete();\n});"
    },

    "Scan": {
      "name": "Сканирование",
      "command": "let targets = Array.from(game.user.targets);\n\n// actorPermissionLevel — Уровень доступа к родительскому актору токена (из CONST.DOCUMENT_PERMISSION_LEVELS: NONE, LIMITED, OBSERVER, OWNER). Если null — без изменений.\nconst actorPermissionLevel = null;\n\nfunction sort_features(a, b) {\n  return b.system.origin.base - a.system.origin.base;\n}\n\nfunction construct_features(items, origin) {\n  let sc_list = ``;\n  sc_list += `<p>${origin}</p>`;\n  let sc_features = items.filter(f => f.system.origin.name === origin).sort(sort_features);\n  sc_features.forEach(i => {\n    let sc_name = ``;\n    let sc_desc = ``;\n    if (i.system.origin.name === \"EXOTIC\" && !i.system.origin.base) {\n      sc_name = '<code class=\"horus--subtle\">Неизвестная ксеносистема</code>';\n      sc_desc = \"???\";\n    } else {\n      sc_name = i.name;\n      if (i.system.effect) {\n        sc_desc = i.system.effect;\n      } else {\n        sc_desc = \"Нет описания\";\n      }\n      if (i.system.trigger) {\n        sc_desc = `Триггер: ${i.system.trigger}<br>${sc_desc}`;\n      }\n    }\n    let sc_entry = `<details><summary>${sc_name}</summary><p>${sc_desc}</p></details>`;\n    sc_list += sc_entry;\n  });\n  return sc_list;\n}\n\nfunction construct_templates(items) {\n  let sc_templates = ``;\n  if (!items || items.length == 0) {\n    sc_templates += \"<p>Нет</p>\";\n  } else {\n    items.forEach(i => {\n      sc_templates += `<p>${i.name}</p>`;\n    });\n  }\n\n  sc_templates += \"<br>\";\n  return sc_templates;\n}\n\ntargets.forEach(target => {\n  let actor = target.actor;\n  if (actorPermissionLevel !== null) {\n    const actorId = actor.system.parent._id;\n    const parentActor = game.actors.get(actorId);\n    parentActor.update({ ownership: { default: actorPermissionLevel } });\n  }\n  let items = actor.items;\n  let hase_table_html = `\n<table>\n  <tr>\n    <th>Корпус</th><th>Ловкость</th><th>Системы</th><th>Инженерия</th>\n  </tr>\n  <tr>\n    <td>${actor.system.hull || 0}</td>\n    <td>${actor.system.agi || 0}</td>\n    <td>${actor.system.sys || 0}</td>\n    <td>${actor.system.eng || 0}</td>\n  </tr>\n</table>`;\n  let stat_table_html = `\n<table>\n  <tr>\n    <th>Броня</th><th>HP</th><th>Нагрев</th><th>Скорость</th>\n  </tr>\n  <tr>\n    <td>${actor.system.armor}</td>\n    <td>${actor.system.hp.value}/${actor.system.hp.max}</td>\n    <td>${actor.system.heat.value || 0}/${actor.system.heat.max || 0}</td>\n    <td>${actor.system.speed}</td>\n  </tr>\n  <tr>\n    <th>Уклонение</th><th>Э-защита</th><th>Порог сейва</th><th>Сенсоры</th>\n  </tr>\n  <tr>\n    <td>${actor.system.evasion}</td>\n    <td>${actor.system.edef}</td>\n    <td>${actor.system.save}</td>\n    <td>${actor.system.sensor_range}</td>\n  </tr>\n  <tr>\n    <th>Размер</th><th>Активации</th><th>Структура</th><th>Стресс</th>\n  </tr>\n  <tr>\n    <td>${actor.system.size}</td>\n    <td>${actor.system.activations || 1}</td>\n    <td>${actor.system.structure.value || 0}/${actor.system.structure.max || 0}</td>\n    <td>${actor.system.stress.value || 0}/${actor.system.stress.max || 0}</td>\n  </tr>\n</table>`;\n  console.log(\"Сканирование\", target);\n  const classes = items.filter(i => i.is_npc_class());\n  let sc_class = !classes || classes.length === 0 ? \"Нет\" : classes[0].name;\n  let sc_tier = actor.system.tier;\n  const templates = items.filter(i => i.is_npc_template());\n  let sc_templates = construct_templates(templates);\n  let sc_list = ``;\n  const features = items.filter(i => i.is_npc_feature());\n  if (!features || features.length === 0) {\n    sc_list += \"<p>Нет</p>\";\n  } else {\n    let sc_origins = [];\n    features.forEach(f => {\n      let origin = f.system.origin.name;\n      if (!sc_origins.includes(origin)) {\n        sc_origins.push(origin);\n      }\n    });\n    sc_origins.forEach(origin => {\n      sc_list += construct_features(features, origin);\n    });\n  }\n\n  ChatMessage.create({\n    user: game.user._id,\n    content:\n      `<h2>Результаты сканирования: ${actor.name}</h2>` +\n      `<h3>Класс: ${sc_class}, Уровень ${sc_tier}</h3>` +\n      hase_table_html +\n      stat_table_html +\n      `<h3>Шаблоны:</h3>` +\n      sc_templates +\n      `<h3>Системы:</h3>` +\n      sc_list,\n    \"flags.core.canPopout\": true,\n  });\n});"
    },

    "Scan (Journal)": {
      "name": "Сканирование (Журнал)",
      "command": "// Проверка вменяемости — может ли пользователь создавать папки и записи журнала? Существует ли папка журнала?\nif (JournalEntry.canUserCreate(game.user) == false) {\n  ui.notifications.error(\n    `${game.user.name} попытался(лась) выполнить СКАН в журнал, но не имеет достаточных прав. Исправьте права и попробуйте снова.`\n  );\n  return;\n}\n\n// ======================================================\n// Переменные — измените для настройки макроса\n// ======================================================\n\n// outputToChat — если true, также отправлять результаты сканирования в чат.\nconst outputToChat = false;\n// journalFolderName — имя папки в Foundry, куда будут сохраняться записи журнала.\nconst journalFolderName = \"База данных сканов\";\n// nameTemplate — текст перед номером скана и именем цели.\nconst nameTemplate = \"SCAN: \";\n// numberLength — длина номера скана (недостающие цифры заполняются нулями).\nconst numberLength = 3;\n// startingNumber — начальный номер скана (если нужен не с 1).\nconst startingNumber = 1;\n// permissionLevel — уровень доступа к записи скана (CONST.DOCUMENT_OWNERSHIP_LEVELS: NONE, LIMITED, OBSERVER, OWNER).\nconst permissionLevel = CONST.DOCUMENT_OWNERSHIP_LEVELS.OWNER;\n// updateExisting — при true макрос ищет и обновляет существующую запись, иначе создаёт новую.\nconst updateExisting = true;\n// actorPermissionLevel — уровень доступа для родительского актора токена (CONST.DOCUMENT_PERMISSION_LEVELS). null — без изменений.\nconst actorPermissionLevel = null;\n// targets — выбранные цели пользователя.\nlet targets = Array.from(game.user.targets);\n\n// ===========================================================\n// ДАЛЕЕ НЕ ИЗМЕНЯТЬ, ЕСЛИ НЕ УВЕРЕНЫ\n// ===========================================================\n\nfunction zeroPad(num, places) {\n  return String(num).padStart(places, \"0\");\n}\n\nfunction findItemByType(array, itemType) {\n  return array.filter(item => item.type === itemType);\n}\n\nfunction sort_features(a, b) {\n  return b.system.origin.base - a.system.origin.base;\n}\n\nfunction construct_features(items, origin) {\n  let sc_list = ``;\n  sc_list += `<p>${origin}</p>`;\n  let sc_features = items.filter(f => f.system.origin && f.system.origin.name === origin).sort(sort_features);\n  sc_features.forEach(i => {\n    let sc_name = ``;\n    let sc_desc = ``;\n    if (i.system.origin.name == \"EXOTIC\" && !i.system.origin.base) {\n      sc_name = '<code class=\"horus--subtle\">Неизвестная ксеносистема</code>';\n      sc_desc = \"???\";\n    } else {\n      sc_name = i.name;\n      if (i.system.effect) {\n        sc_desc = i.system.effect;\n      } else {\n        sc_desc = \"Нет описания\";\n      }\n      if (i.system.trigger) {\n        sc_desc = `Триггер: ${i.system.trigger}<br>${sc_desc}`;\n      }\n    }\n    if (!sc_desc.startsWith(\"<p>\") && !sc_desc.startsWith(\"<P>\")) sc_desc = `<p>${sc_desc}</p>`;\n    let sc_entry = `<details><summary>${sc_name}</summary>${sc_desc}</details>`;\n    sc_list += sc_entry;\n  });\n  return sc_list;\n}\n\nfunction construct_weapons(items, origin, tier) {\n  let sc_weapons = ``;\n  let sc_features = items\n    .filter(i => i.system.origin && i.system.origin.name === origin && i.system.type === \"Weapon\")\n    .sort(sort_features);\n  sc_features.forEach(i => {\n    let sc_name = ``;\n    let sc_desc = ``;\n    let sc_entry = ``;\n    let sc_range = ``;\n    let sc_damage = ``;\n    let sc_accuracy = ``;\n    if (!i.type) {\n      return sc_weapons;\n    }\n    sc_weapons += `<table>`;\n    if (i.system.origin.name == \"EXOTIC\" && !i.system.origin.base) {\n      sc_name = '<tr><th><code class=\"horus--subtle\">Неизвестное ксенооружие</code></th></tr>';\n      sc_desc = \"<tr><td>???</td></tr>\";\n      sc_entry = sc_name + sc_desc;\n    } else {\n      sc_name = `<tr><th colspan=\\\"4\\\">${i.name}</th></tr>`;\n      sc_entry += sc_name;\n      sc_desc = `<tr>`;\n      sc_desc += `<td>+${i.system.attack_bonus[tier - 1]} к атаке</td>`;\n      if (i.system.accuracy[tier - 1]) {\n        let acc = i.system.accuracy[tier - 1];\n        sc_accuracy = `${acc > 0 ? \"+\" : \"\"}${acc} ${acc > 0 ? \"Точность\" : \"Сложность\"}`;\n      }\n      sc_desc += `<td>${sc_accuracy}</td>`;\n      if (i.system.range.length > 0) {\n        i.system.range.forEach(r => (sc_range += r.type + \" \" + r.val + \"&nbsp&nbsp&nbsp\"));\n      }\n      sc_desc += `<td>${sc_range}</td>`;\n      if (i.system.damage.length > 0) {\n        i.system.damage[tier - 1].forEach(d => (sc_damage += d.val + \" \" + d.type + \"&nbsp&nbsp&nbsp\"));\n      }\n      sc_desc += `<td>${sc_damage}</td>`;\n      if (i.system.tags.some(t => t.is_loading)) {\n        if (i.system.loaded) {\n          sc_desc += `<td>Заряжено</td>`;\n        } else {\n          sc_desc += `<td>Не заряжено</td>`;\n        }\n      } else {\n        sc_desc += `<td></td>`;\n      }\n      if (i.system.uses.max > 0) {\n        sc_desc += `<td>ЗАРЯДЫ: ${i.system.uses.value}/${i.system.uses.max}</td>`;\n      }\n      sc_desc += `<tr>`;\n      if (i.system.trigger) {\n        sc_desc += `<tr><td colspan=\\\"6\\\"><details><summary>Триггер</summary><p>${i.system.trigger}</p></details></td></tr>`;\n      }\n      if (i.system.on_hit) {\n        sc_desc += `<tr><td colspan=\\\"6\\\"><details><summary>При попадании</summary><p>${i.system.on_hit}</p></details></td></tr>`;\n      }\n      if (i.system.effect) {\n        sc_desc += `<tr><td colspan=\\\"6\\\">${i.system.effect}</td></tr>`;\n      }\n      if (i.system.tags.length > 0) {\n        sc_desc += `<tr><td colspan=\\\"6\\\">Теги: `;\n        sc_desc += i.system.tags.map(t => `${t.name.replace(\"{VAL}\", t.val)}`).join(\", \");\n        sc_desc += `</td></tr>`;\n      }\n      sc_entry += sc_desc;\n    }\n    sc_weapons += sc_entry;\n    sc_weapons += `</table>`;\n  });\n  return sc_weapons;\n}\n\nfunction construct_templates(items) {\n  let templatefind = findItemByType(items, \"npc_template\");\n  let sc_templates = ``;\n  let sc_temp = templatefind;\n  if (!sc_temp || sc_temp.length == 0) {\n    sc_templates += \"<p>Нет</p>\";\n  } else {\n    sc_temp.forEach(i => {\n      let sc_entry = `<p>${i.name}</p>`;\n      sc_templates += sc_entry;\n    });\n  }\n  return sc_templates;\n}\n\n// Найти или создать папку для сканов\nlet journalFolder = game.folders.getName(journalFolderName);\nif (!journalFolder && journalFolderName.length > 0) {\n  try {\n    journalFolder = await Folder.create({\n      name: journalFolderName,\n      type: \"JournalEntry\",\n    });\n  } catch (error) {\n    ui.notifications.error(\n      `${journalFolderName} не существует — её должен создать пользователь с правами.`\n    );\n    return;\n  }\n}\n\n// Создать запись журнала для каждой цели\ntargets.forEach(async target => {\n  let actor = target.actor;\n  if (actorPermissionLevel !== null) {\n    const actorId = actor.system.parent._id;\n    const parentActor = game.actors.get(actorId);\n    parentActor.update({ ownership: { default: actorPermissionLevel } });\n  }\n  console.log(\"Сканируем цель:\", actor);\n  let items = actor.items;\n  let hase_table_html = `\n<p><img style=\\\"border: 3px dashed #000000; float: left; margin-right: 5px; margin-left: 5px;\\\" src=\\\"${\n    target.document.actor.img\n  }\\\" width=\\\"30%\\\" height=\\\"30%\\\" /></p>\n<div style=\\\"color: #000000; width: 65%; float: right; text-align: left;\\\">\n<table>\n  <tr>\n    <th>Корпус</th><th>Ловкость</th><th>Системы</th><th>Инженерия</th>\n  </tr>\n  <tr>\n    <td>${actor.system.hull || 0}</td>\n    <td>${actor.system.agi || 0}</td>\n    <td>${actor.system.sys || 0}</td>\n    <td>${actor.system.eng || 0}</td>\n  </tr>\n</table> `;\n  let stat_table_html = `\n<table>\n  <tr>\n    <th>Броня</th><th>HP</th><th>Нагрев</th><th>Скорость</th>\n  </tr>\n  <tr>\n    <td>${actor.system.armor}</td>\n    <td>${actor.system.hp.value}/${actor.system.hp.max}</td>\n    <td>${actor.system.heat.value || 0}/${actor.system.heat.max || 0}</td>\n    <td>${actor.system.speed}</td>\n  </tr>\n  <tr>\n    <th>Уклонение</th><th>Э-защита</th><th>Порог сейва</th><th>Сенсоры</th>\n  </tr>\n  <tr>\n    <td>${actor.system.evasion}</td>\n    <td>${actor.system.edef}</td>\n    <td>${actor.system.save}</td>\n    <td>${actor.system.sensor_range}</td>\n  </tr>\n  <tr>\n    <th>Размер</th><th>Активации</th><th>Структура</th><th>Стресс</th>\n  </tr>\n  <tr>\n    <td>${actor.system.size}</td>\n    <td>${actor.system.activations || 1}</td>\n    <td>${actor.system.structure.value || 0}/${actor.system.structure.max || 0}</td>\n    <td>${actor.system.stress.value || 0}/${actor.system.stress.max || 0}</td>\n  </tr>\n</table> `;\n  console.log(items);\n  let sc_class = !actor.system.class ? \"Нет\" : actor.system.class.name;\n  let sc_tier = actor.system.tier ? actor.system.tier : 0;\n  let sc_templates = construct_templates(items);\n  let sc_list = ``;\n  let sc_weapons = ``;\n  if (!items || items.length == 0) {\n    sc_list += \"<p>Нет</p>\";\n    sc_weapons += \"<p>Нет</p>\";\n  } else {\n    let sc_origins = [];\n\n    items.forEach(f => {\n      let origin = f.system.origin?.name;\n      if (origin && !sc_origins.includes(origin)) {\n        sc_origins.push(origin);\n      }\n    });\n\n    sc_origins.forEach(origin => {\n      sc_list += construct_features(items, origin);\n      sc_weapons += construct_weapons(items, origin, sc_tier);\n    });\n  }\n\n  if (outputToChat) {\n    ChatMessage.create({\n      user: game.user._id,\n      content: `<h2>Результаты сканирования: ${actor.name}</h2>\n        <h3>Класс: ${sc_class}, Уровень ${sc_tier}</h3>\n        ${hase_table_html}\n        ${stat_table_html}\n        <h3>Шаблоны:</h3>\n        ${sc_templates}\n        <h3>Системы:</h3>\n        ${sc_list}`,\n    });\n  }\n\n  let scanContent =\n    `<h2>Результаты сканирования: ${actor.name}</h2>` +\n    `<h3>Класс: ${sc_class}, Уровень ${sc_tier}</h3>` +\n    hase_table_html +\n    stat_table_html +\n    `</div><div style=\\\"color: #000000; width: 100%; float: right; text-align: left;\\\"><h3>Шаблоны:</h3>` +\n    sc_templates +\n    `<h3>Оружие:</h3>` +\n    sc_weapons +\n    `<h3>Системы:</h3>` +\n    sc_list +\n    `</div>`;\n\n  // Проверка и обновление существующей записи скана при наличии ровно одной, иначе — создание новой.\n\n  let scanEntry;\n\n  let matchingJournalEntries = journalFolder.contents.filter(e => e.name.includes(actor.name));\n\n  if (matchingJournalEntries.length == 1 && updateExisting === true) {\n    console.log(\"Обновление существующего скана\");\n    const scanName = matchingJournalEntries[0].name;\n    scanEntry = game.journal.getName(scanName);\n    let scanPage = scanEntry.pages.getName(scanName);\n    await scanPage.update({\n      _id: matchingJournalEntries[0]._id,\n      text: {\n        content: scanContent,\n      },\n    });\n  } else {\n    console.log(\"Создание нового скана\");\n    let scanCount = zeroPad(\n      journalFolder.contents.filter(e => e.name.startsWith(nameTemplate)).length + startingNumber,\n      numberLength\n    );\n    const scanName = nameTemplate + scanCount + ` - ` + actor.name;\n    let scanPage = new JournalEntryPage({\n      name: scanName,\n      type: \"text\",\n      text: { content: scanContent },\n    });\n    scanEntry = await JournalEntry.create({\n      folder: journalFolder.id,\n      name: scanName,\n    });\n    scanEntry.createEmbeddedDocuments(\"JournalEntryPage\", [scanPage]);\n  }\n\n  scanEntry.update({ permission: { default: permissionLevel } });\n  scanEntry.sheet.render(true);\n});"
    },

    "Full Repair": {
      "name": "Полный ремонт",
      "command": "if (canvas.tokens.controlled.length !== 1) {\n  ui.notifications.error(\"Пожалуйста, выберите одну цель\");\n  return;\n}\ncanvas.tokens.controlled[0].actor.beginFullRepairFlow();"
    },

    "Overheat Token": {
      "name": "Перегрев",
      "command": "if (canvas.tokens.controlled.length !== 1) {\n  ui.notifications.error(\"Пожалуйста, выберите одну цель\");\n  return;\n}\ncanvas.tokens.controlled[0].actor.beginOverheatFlow();"
    },

    "Stabilize Token": {
      "name": "Стабилизация",
      "command": "if (canvas.tokens.controlled.length !== 1) {\n  ui.notifications.error(\"Пожалуйста, выберите одну цель\");\n  return;\n}\ncanvas.tokens.controlled[0].actor.beginStabilizeFlow();"
    },

    "Structure Token": {
      "name": "Повреждение структуры",
      "command": "if (canvas.tokens.controlled.length !== 1) {\n    ui.notifications.error(\"Пожалуйста, выберите одну цель\");\n    return;\n}\ncanvas.tokens.controlled[0].actor.beginStructureFlow();"
    }
  }
}
